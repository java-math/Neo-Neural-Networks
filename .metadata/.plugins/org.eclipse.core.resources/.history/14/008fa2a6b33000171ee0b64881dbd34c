package net.mileselvidge.neo;


import java.lang.reflect.Method;

/*
 * Neo: Java Machine Learning Library
 * A Machine Learning library for Java containing Neural Networks and Matrix Mathematics
 * by Miles Elvidge, 17
 * Contact: miles.elvidge@ntlworld.com
 * Started 01/05/17
 */

public class DeepNeuralNetwork {
	// A not so basic deep neural network structure
	
	// Number of nodes in different layers
	private int[] layers;
	
	// Functions for calculating activation and derivatives
	private Method activation;
	private Method derivative;
	
	// Weight Matrices
	private NMatrix[] weights;
	private NMatrix wIH;
	private NMatrix wHO;
	
	public double learningRate;
	
	// Constructors 

	// Initialise from scratch 
	public DeepNeuralNetwork(int inputSize, int hiddenSizes[], int outputSize, double lr, String activationType) {
		// Initialise layers of neural network
		this.layers = new int[hiddenSizes.length+2];
		
		// Initialise input/output layers of the neural network
		this.layers[0] = inputSize;
		this.layers[this.layers.length-1] = outputSize;
		
		// Initialise hidden layers
		for(int i = 1; i < this.layers.length-1; i++) {
			this.layers[i] = hiddenSizes[i-1];
		}
		
		this.learningRate = lr;
		
		// Initialise weights with random gaussian values
		weights = new NMatrix[this.layers.length-1];
		for(int i = 0; i < weights.length; i++) {
			weights[i] = NMatrix.random(this.layers[i+1], this.layers[i]);
 		}
		
		// Initialise the activation/derivative functions
		NMath math = new NMath();
		try {
			if(activationType.toLowerCase() == "tanh"){
				activation = math.getClass().getMethod("tanh", Double.TYPE);
				derivative = math.getClass().getMethod("dtanh", Double.TYPE);
			} else {
				// Default
				activation = math.getClass().getMethod("Sigmoid", Double.TYPE);
				derivative = math.getClass().getMethod("dSigmoid", Double.TYPE);
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
	
	// Initialise a neural network from a neural network
	public DeepNeuralNetwork(DeepNeuralNetwork net){
		this.layers = net.layers;
		this.learningRate = net.learningRate;
		this.weights = net.weights;
		this.activation = net.activation;
		this.derivative = net.derivative;
	}
	
	public DeepNeuralNetwork copy() {
		return new DeepNeuralNetwork(this); 
	}
	
	// Query the network
	public double[] query(double[] inputsArr){
		try {
			// Convert inputs array to a matrix
			NMatrix inputs = NMatrix.fromArray(inputsArr);
			NMatrix current = inputs.copy();
			
			for(int i = 0; i < weights.length; i++) {
				NMatrix hidden1 = NMatrix.multiply(weights[i], current);
				NMatrix hidden2 = NMatrix.map(hidden1, this, this.activation);
			}
			
			// Move from input to hidden layer by multiplying weights (wIH) and inputs
			NMatrix hiddenInputs = NMatrix.multiply(this.wIH, inputs);
			
			// Move from hidden layer to outputs using sigmoid activation function
			NMatrix hiddenOutputs = NMatrix.map(hiddenInputs, this, this.activation);
			
			// The input-output layer is the weights (wHO) * the hidden layer
			NMatrix outputInputs = NMatrix.multiply(this.wHO, hiddenOutputs);
			
			// The output of the network must once more be passed through the sigmoid/tanh activation function
			NMatrix outputs = NMatrix.map(outputInputs, this, this.activation);
			
			return outputs.transpose().asArray()[0]; // as regular 1D array like inputs
		} catch (Exception e) {
			System.out.println("Fatal Error occoured: contact developer!");
			return new double[] {0};
		}
	}
	
	// Train the neural network
	public void train(double[] inputsArr, double[] targetArr) {
		try {
			// Turn inputs & targets in matrices
			NMatrix inputs = NMatrix.fromArray(inputsArr);
			NMatrix targets = NMatrix.fromArray(targetArr);
			
			// Input to hidden layer is wIH multiplied by the inputs
			NMatrix hiddenInputs = NMatrix.multiply(this.wIH, inputs);
			
			// Then the outputs of the hidden layer are passed through the activation function
			NMatrix hiddenOutputs = NMatrix.map(hiddenInputs, this, this.activation);
			
			// Input-to-output layer is weights (wHO) multiplied by hidden layer
			NMatrix outputInputs = NMatrix.multiply(this.wHO, hiddenOutputs);
			
			// The output of the network passes through the sigmoid function oncemore...
			NMatrix outputs = NMatrix.map(outputInputs, this, this.activation);
			
			// Calculate error
			// This is target - output
			NMatrix outputErrors = NMatrix.subtract(targets, outputs);
			
			// Commence back propagation (Output <-> Hidden)
			// Transpose hidden to output layer
			NMatrix wHO_T = this.wHO.transpose();
			
			// Multiply output error by weights (wHO) for hidden errors
			NMatrix hiddenErrors = NMatrix.multiply(wHO_T, outputErrors);
			
			// Calculate the gradient of high dimensional surface...
			NMatrix grad_out = NMatrix.map(outputs, this, this.derivative);
			
			// Weigh by error and learning rate
			grad_out = NMatrix.dotMultiply(grad_out, outputErrors);
			grad_out = grad_out.scale(this.learningRate);
			
			// Continue back propagating (Hidden <-> Input)
			NMatrix grad_hidden = NMatrix.map(hiddenOutputs, this, this.derivative);
			grad_hidden = NMatrix.dotMultiply(grad_hidden, hiddenErrors);
			grad_hidden = grad_hidden.scale(this.learningRate);
			
			// Change weights
			// Calculate delta (Input -> Hidden)
			NMatrix inputs_T = inputs.transpose();
			NMatrix delta_hidden = NMatrix.multiply(grad_hidden, inputs_T);
			this.wIH = NMatrix.add(this.wIH, delta_hidden); // Update 
			
			// Calculate delta (Hidden -> Output)
			NMatrix hidden_outputs_T = hiddenOutputs.transpose();
			NMatrix delta_output = NMatrix.multiply(grad_out, hidden_outputs_T);
			this.wHO = NMatrix.add(this.wHO, delta_output);
		} catch (Exception e) {
			System.out.println("Fatal Error occoured: contact developer!");
			e.printStackTrace();
		}
	}
}